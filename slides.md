---
layout: page
title: Slides and Code
---
**Verifying cyberphysical systems**, by _Sayan Mitra_. 
To be published by _MIT Press_. 

# Chapters

1. ### Introduction
  * slides [pptx](Slides/Introduction-cps.pptx) [pdf](Slides/Introduction-cps.pdf)

2. ### Modeling computation
  * slides [pptx](Slides/ModelingComputation.pptx) [pdf](Slides/ModelingComputation.pdf)
  * code [ipynb](https://gitlab.engr.illinois.edu/mitras/cps_bookcode/tree/master/Chapter%202/Notebook)
<!--
 {2.1}Quick introduction to automata}{15}{section.2.1}
 {subsection}{\numberline {2.1.1}Example: JK flip flop}{15}{subsection.2.1.1}
 {subsection}{\numberline {2.1.2}Language for specifying automata}{15}{subsection.2.1.2}
 {2.2}Specifying automata}{17}{section.2.2}
 {subsection}{\numberline {2.2.1}State variables and valuations}{17}{subsection.2.2.1}
 {subsection}{\numberline {2.2.2}Predicates}{18}{subsection.2.2.2}
 {subsection}{\numberline {2.2.3}Transitions}{18}{subsection.2.2.3}
 {subsection}{\numberline {2.2.4}Automata}{19}{subsection.2.2.4}
 {2.3}Special automata classes}{20}{section.2.3}
 {subsection}{\numberline {2.3.1}Finite and discrete automata}{20}{subsection.2.3.1}
 {subsection}{\numberline {2.3.2}Nondeterminism}{20}{subsection.2.3.2}
 {subsection}{\numberline {2.3.3}Discrete sequences and sampled time}{20}{subsection.2.3.3}
 {2.4}Semantics: Executions, reachable states, and invariants}{21}{section.2.4}
 {2.5}Example: Dijkstra's token ring algorithm}{21}{section.2.5}
 {paragraph}{Multiple transition definitions for the same action}{22}{section*.21}
 {subsection}{\numberline {2.5.1}Legal states and invariants}{23}{subsection.2.5.1}
 {subsection}{\numberline {2.5.2}Asynchronous and synchronous models}{23}{subsection.2.5.2}
 {2.6}Example: Reasoning about impossibility}{24}{section.2.6}
 {2.7}Problems}{25}{section.2.7}
 -->
3. ### Modeling physics
<!--
 {paragraph}{Overview}{27}{section*.22}
 {3.1}Quick introduction to differential equations\/}{27}{section.3.1}
 {subsection}{\numberline {3.1.1}Example: Vehicle speed control}{27}{subsection.3.1.1}
 {subsection}{\numberline {3.1.2}Language for specifying differential equations}{27}{subsection.3.1.2}
 {3.2}Specifying ordinary differential equations\/}{29}{section.3.2}
 {subsection}{\numberline {3.2.1}State variables and valuations}{29}{subsection.3.2.1}
 {subsection}{\numberline {3.2.2}Dense time and trajectories}{29}{subsection.3.2.2}
 {subsection}{\numberline {3.2.3}Trajectories as solutions}{30}{subsection.3.2.3}
 {3.3}Special classes of ODEs}{33}{section.3.3}
 {subsection}{\numberline {3.3.1}Time-invariant and autonomous systems}{33}{subsection.3.3.1}
 {subsection}{\numberline {3.3.2}Linear systems}{33}{subsection.3.3.2}
 {3.4}Semantics: Reachable states, invariants, and stability}{34}{section.3.4}
 {subsection}{\numberline {3.4.1}Example: Pendulum}{35}{subsection.3.4.1}
 {3.5}Lyapunov's direct method for proving stability}{36}{section.3.5}
 {subsection}{\numberline {3.5.1}Stability of linear dynamical systems}{37}{subsection.3.5.1}
 {3.6}Differential equations as automata}{38}{section.3.6}
 {3.7}Example: Simple economy}{38}{section.3.7}
 {3.8}Numerical simulations for ordinary differential equations}{40}{section.3.8}
 {3.9}Closing the loop and control synthesis}{41}{section.3.9}
 {subsection}{\numberline {3.9.1}PID controller}{43}{subsection.3.9.1}
 {paragraph}{Summary and outlook.}{44}{section*.23}
 {3.10}Problems}{44}{section.3.10}
 -->
4. ### Modeling cyberphysical systems
<!--
 {paragraph}{Overview}{47}{section*.24}
 {4.1}Quick introduction to hybrid automata}{47}{section.4.1}
 {subsection}{\numberline {4.1.1}Example: Rimless wheel}{47}{subsection.4.1.1}
 {subsection}{\numberline {4.1.2}Language for specifying hybrid systems}{48}{subsection.4.1.2}
 {4.2}Specifying hybrid automata}{50}{section.4.2}
 {subsection}{\numberline {4.2.1}State variables and transitions}{50}{subsection.4.2.1}
 {subsection}{\numberline {4.2.2}Trajectories and closures}{50}{subsection.4.2.2}
 {subsection}{\numberline {4.2.3}Hybrid automata}{52}{subsection.4.2.3}
 {4.3}Special classes of hybrid automata}{53}{section.4.3}
 {subsection}{\numberline {4.3.1}Deterministic hybrid automata}{53}{subsection.4.3.1}
 {subsection}{\numberline {4.3.2}Switched systems}{53}{subsection.4.3.2}
 {subsection}{\numberline {4.3.3}Linear hybrid automata}{54}{subsection.4.3.3}
 {subsection}{\numberline {4.3.4}Rectangular hybrid automata}{56}{subsection.4.3.4}
 {subsection}{\numberline {4.3.5}Timed automata}{56}{subsection.4.3.5}
 {4.4}Semantics: Hybrid executions}{56}{section.4.4}
 {subsection}{\numberline {4.4.1}Numerical simulation of hybrid executions}{58}{subsection.4.4.1}
 {subsection}{\numberline {4.4.2}Reachable states, invariants, stability}{59}{subsection.4.4.2}
 {subsection}{\numberline {4.4.3}Time-abstract semantics}{60}{subsection.4.4.3}
 {subsection}{\numberline {4.4.4}Execution zoo}{62}{subsection.4.4.4}
 {4.5}Example: Spacecraft docking}{62}{section.4.5}
 {4.6}Example: Small aircraft traffic management system}{63}{section.4.6}
 {4.7}Problems}{65}{section.4.7}
 -->
5. ### Composing models
<!-- 
 {paragraph}{Overview}{69}{section*.26}
 {5.1}Composing automata}{69}{section.5.1}
 {5.2}Composing Input/Output automata}{70}{section.5.2}
 {subsection}{\numberline {5.2.1}Input/Output automata}{70}{subsection.5.2.1}
 {subsection}{\numberline {5.2.2}Compatibility and composition of Input/Output automata}{70}{subsection.5.2.2}
 {5.3}Example: Channels, logical clocks, and distributed systems}{71}{section.5.3}
 {subsection}{\numberline {5.3.1}FIFO channels}{71}{subsection.5.3.1}
 {subsection}{\numberline {5.3.2}Logical time in distributed systems: Lamport clocks}{72}{subsection.5.3.2}
 {subsection}{\numberline {5.3.3}Composed system: Network of processes communicating over channels}{74}{subsection.5.3.3}
 {paragraph}{Behaviors of the composed system}{75}{section*.27}
 {subsection}{\numberline {5.3.4}Traces and projections}{75}{subsection.5.3.4}
 {5.4}Composing Hybrid Input/Output Automata}{77}{section.5.4}
 {subsection}{\numberline {5.4.1}Hybrid Input/Output Automata}{77}{subsection.5.4.1}
 {subsection}{\numberline {5.4.2}Compatibility and composition of hybrid input/output automata}{78}{subsection.5.4.2}
 {5.5}Example: Timed channels}{79}{section.5.5}
 {5.6}Example: Pulse generator and oscillator}{80}{section.5.6}
 {5.7}Traces, untiming, and properties of compositions}{81}{section.5.7}
 {5.8}Example: Emergency braking on highways}{83}{section.5.8}
 {5.9}Problems}{85}{section.5.9}
 -->
6. ### Specifying requirements
<!-- 
 {paragraph}{Overview}{87}{section*.28}
 {6.1}Requirements analysis}{87}{section.6.1}
 {6.2}Safety standards}{88}{section.6.2}
 {subsection}{\numberline {6.2.1}DO-178C}{88}{subsection.6.2.1}
 {subsection}{\numberline {6.2.2}ISO 26262}{89}{subsection.6.2.2}
 {subsection}{\numberline {6.2.3}Beyond safety standards and requirements}{91}{subsection.6.2.3}
 {6.3}Formal requirements, verification, and monitoring}{91}{section.6.3}
 {paragraph}{Runtime verification or monitoring}{92}{section*.29}
 {subsection}{\numberline {6.3.1}Invariants and safety requirements}{92}{subsection.6.3.1}
 {subsection}{\numberline {6.3.2}Progress requirements}{94}{subsection.6.3.2}
 {6.4}Linear temporal logic}{95}{section.6.4}
 {subsection}{\numberline {6.4.1}Background definitions}{96}{subsection.6.4.1}
 {paragraph}{Atomic propositions}{96}{section*.30}
 {paragraph}{Automaton with state labels}{96}{section*.31}
 {subsection}{\numberline {6.4.2}LTL syntax}{97}{subsection.6.4.2}
 {subsection}{\numberline {6.4.3}LTL semantics}{97}{subsection.6.4.3}
 {paragraph}{Semantics of LTL for discrete and hybrid automata}{99}{section*.32}
 {6.5}Computation tree logic (CTL)}{100}{section.6.5}
 {subsection}{\numberline {6.5.1}CTL syntax}{100}{subsection.6.5.1}
 {subsection}{\numberline {6.5.2}CTL semantics}{100}{subsection.6.5.2}
 {subsection}{\numberline {6.5.3}Expressiveness of LTL and CTL}{101}{subsection.6.5.3}
 {6.6}Further reading}{102}{section.6.6}
 {subsection}{\numberline {6.6.1}Temporal logic model checking}{102}{subsection.6.6.1}
 {subsection}{\numberline {6.6.2}Planning and synthesis with temporal logics}{102}{subsection.6.6.2}
 {subsection}{\numberline {6.6.3}Dense time, signal, and stochastic temporal logics}{103}{subsection.6.6.3}
 {6.7}Problems}{104}{section.6.7}
 -->
7. ### Verifying invariants
  * Satisfiability and satisfiability modulo theories: slides [pptx](Slides/sat-smt.pptx)
<!-- 
 {7.1}Quick introduction to proving invariants}{105}{section.7.1}
 {paragraph}{Floyd-Hoare logic}{107}{section*.34}
 {7.2}Reasoning with inductive invariants}{107}{section.7.2}
 {subsection}{\numberline {7.2.1}Invariance and composition}{109}{subsection.7.2.1}
 {7.3}Proving mutual exclusion in Fischer's algorithm}{109}{section.7.3}
 {subsection}{\numberline {7.3.1}Example: Fischer's mutual exclusion}{109}{subsection.7.3.1}
 {subsection}{\numberline {7.3.2}Analysis of Fischer's mutual exclusion}{111}{subsection.7.3.2}
 {7.4}Proving inductive invariants without solving ODEs}{115}{section.7.4}
 {subsection}{\numberline {7.4.1}Example: checking subtangential conditions}{116}{subsection.7.4.1}
 {subsection}{\numberline {7.4.2}Barrier certificates}{117}{subsection.7.4.2}
 {7.5}Satisfiability and satisfiability modulo theories}{118}{section.7.5}
 {subsection}{\numberline {7.5.1}SAT}{118}{subsection.7.5.1}
 {subsection}{\numberline {7.5.2}SMT}{119}{subsection.7.5.2}
 {subsection}{\numberline {7.5.3}Modeling for SAT and SMT}{121}{subsection.7.5.3}
 {7.6}Further reading}{122}{section.7.6}
 {subsection}{\numberline {7.6.1}Finding and learning invariants}{122}{subsection.7.6.1}
 {paragraph}{Invariant generation with templates}{123}{section*.35}
 {paragraph}{Learning invariants by using execution data}{123}{section*.36}
 {7.7}Problems}{123}{section.7.7}
 -->
8. ### Abstractions and compositional reasoning
<!--
 {8.1}Quick introduction to abstractions: Timing abstraction}{125}{section.8.1}
 {8.2}Abstraction definitions}{128}{section.8.2}
 {8.3}Proving abstractions: Simulation relations}{129}{section.8.3}
 {8.4}Bisimulations and time-abstract bisimulations}{132}{section.8.4}
 {subsection}{\numberline {8.4.1}Untiming and bisimulations}{132}{subsection.8.4.1}
 {subsection}{\numberline {8.4.2}Example: Simulation and trace inclusion}{133}{subsection.8.4.2}
 {subsection}{\numberline {8.4.3}Backward simulations}{134}{subsection.8.4.3}
 {8.5}Hybridization}{135}{section.8.5}
 {8.6}Substituting with abstractions}{135}{section.8.6}
 {8.7}CEGAR}{137}{section.8.7}
 {subsection}{\numberline {8.7.1}Designing a CEGAR-based CPS verification system}{139}{subsection.8.7.1}
 {paragraph}{Space of abstractions}{139}{section*.38}
 {paragraph}{Model checker}{139}{section*.39}
 {paragraph}{Counterexample validation}{140}{section*.40}
 {paragraph}{Refinement strategy}{141}{section*.41}
 {8.8}Problems}{141}{section.8.8}
 -->
9. ### Reachability analysis 
<!--
 {9.1}Quick introduction to reachability analysis}{143}{section.9.1}
 {9.2}Finite automata}{144}{section.9.2}
 {subsection}{\numberline {9.2.1}Finite state reachability}{144}{subsection.9.2.1}
 {9.3}Timed automata}{146}{section.9.3}
 {subsection}{\numberline {9.3.1}Syntax for timed automata}{146}{subsection.9.3.1}
 {subsection}{\numberline {9.3.2}Example: Timed light switch}{148}{subsection.9.3.2}
 {subsection}{\numberline {9.3.3}Clock equivalence relation on states}{148}{subsection.9.3.3}
 {subsection}{\numberline {9.3.4}Control state reachability and region automata}{151}{subsection.9.3.4}
 {9.4}Integral timed automata to rectangular hybrid automata}{154}{section.9.4}
 {subsection}{\numberline {9.4.1}Rational timed automata}{154}{subsection.9.4.1}
 {subsection}{\numberline {9.4.2}Multi-rate automata}{154}{subsection.9.4.2}
 {subsection}{\numberline {9.4.3}Rectangular hybrid automata}{155}{subsection.9.4.3}
 {9.5}Undecidability of CSR for rectangular hybrid automata}{155}{section.9.5}
 {subsection}{\numberline {9.5.1}Two counter machines}{156}{subsection.9.5.1}
 {subsection}{\numberline {9.5.2}Reduction of CSR of RHA to Halting problem of 2CM}{157}{subsection.9.5.2}
 {subsection}{\numberline {9.5.3}Rectangular initialized hybrid automata}{159}{subsection.9.5.3}
 {9.6}Relaxing the verification problem}{161}{section.9.6}
 {subsection}{\numberline {9.6.1}Bounded reachability analysis}{161}{subsection.9.6.1}
 {9.7}Data structures for reachability analysis}{163}{section.9.7}
 {subsection}{\numberline {9.7.1}Rectangles}{163}{subsection.9.7.1}
 {paragraph}{Representing rectangular hybrid automata with rectangles}{164}{section*.45}
 {paragraph}{Reachability analysis with rectangles}{164}{section*.46}
 {subsection}{\numberline {9.7.2}Polytopes}{166}{subsection.9.7.2}
 {paragraph}{Linear hybrid automata}{167}{section*.47}
 {paragraph}{Polytope operations}{167}{section*.48}
 {subsection}{\numberline {9.7.3}Zonotopes}{169}{subsection.9.7.3}
 {paragraph}{Zonotopic operations}{170}{section*.49}
 {subsection}{\numberline {9.7.4}Ellipsoids}{170}{subsection.9.7.4}
 {paragraph}{Ellipsoidal operations}{170}{section*.50}
 {paragraph}{Summary}{171}{section*.51}
 {9.8}Problems}{171}{section.9.8}
 -->
10. ### Progress analysis
 <!-- 
 {paragraph}{Overview}{173}{section*.52}
 {10.1}Quick introduction to progress}{173}{section.10.1}
 {10.2}Termination of discrete-time automata}{174}{section.10.2}
 {subsection}{\numberline {10.2.1}Termination with well-founded relations}{174}{subsection.10.2.1}
 {subsection}{\numberline {10.2.2}Example: UpDown counter}{176}{subsection.10.2.2}
 {subsection}{\numberline {10.2.3}Termination with disjunctive well-founded relations}{176}{subsection.10.2.3}
 {subsection}{\numberline {10.2.4}Example: UpDown revisited}{178}{subsection.10.2.4}
 {10.3}Self-stabilization}{178}{section.10.3}
 {subsection}{\numberline {10.3.1}Example: Distributed minimal spanning tree}{179}{subsection.10.3.1}
 {subsection}{\numberline {10.3.2}Stabilization analysis of ${\operatorname {\mathsf {MST}}}$}{180}{subsection.10.3.2}
 {10.4}Convergence and stability without metrics}{182}{section.10.4}
 {subsection}{\numberline {10.4.1}Convergence for finite state systems}{182}{subsection.10.4.1}
 {10.5}Stability proofs for dynamical systems}{184}{section.10.5}
 {10.6}Stability of hybrid automata}{185}{section.10.6}
 {subsection}{\numberline {10.6.1}Common Lyapunov functions}{186}{subsection.10.6.1}
 {subsection}{\numberline {10.6.2}Multiple Lyapunov functions}{187}{subsection.10.6.2}
 {subsection}{\numberline {10.6.3}Stability under slow switching: average dwell time}{188}{subsection.10.6.3}
 {10.7}Problems}{190}{section.10.7}
 -->
11. ### Data-driven verification
<!-- 
 {11.1}Quick introduction to data-driven safety verification}{191}{section.11.1}
 {subsection}{\numberline {11.1.1}Discrepancy functions}{192}{subsection.11.1.1}
 {subsection}{\numberline {11.1.2}${\bf {\operatorname {\mathsf {BasicSimReach}}}}$ Algorithm}{193}{subsection.11.1.2}
 {subsection}{\numberline {11.1.3}Example: Moore-Greitzer jet engine}{195}{subsection.11.1.3}
 {11.2}Computing discrepancy}{195}{section.11.2}
 {subsection}{\numberline {11.2.1}Linear dynamical systems}{196}{subsection.11.2.1}
 {subsection}{\numberline {11.2.2}Example:}{196}{subsection.11.2.2}
 {subsection}{\numberline {11.2.3}Nonlinear dynamical systems: Optimization-based approaches}{196}{subsection.11.2.3}
 {subsection}{\numberline {11.2.4}Nonlinear models: Local discrepancy}{197}{subsection.11.2.4}
 {paragraph}{From locally optimal discrepancy to precise reachsets}{198}{section*.54}
 {11.3}Hybrid system verification}{199}{section.11.3}
 {subsection}{\numberline {11.3.1}C2E2 verification tool}{200}{subsection.11.3.1}
 {subsection}{\numberline {11.3.2}Example: Reachability analysis for ${\operatorname {\mathsf {PulseGen}}}\delimiter "026B30D {\operatorname {\mathsf {Oscillator}}}$ with C2E2}{201}{subsection.11.3.2}
 {11.4}Example: Powertrain control system}{201}{section.11.4}
 {11.5}Verifying cyber-physical systems with incomplete models}{202}{section.11.5}
 {subsection}{\numberline {11.5.1}Hybrid automata with black-box modules}{204}{subsection.11.5.1}
 {subsection}{\numberline {11.5.2}Learning discrepancy from simulations}{205}{subsection.11.5.2}
 {subsection}{\numberline {11.5.3}DryVR verification tool}{207}{subsection.11.5.3}
 {11.6}Example: Analyzing risk in automatic emergency braking systems}{208}{section.11.6}
 {11.7}Example: Autonomous spacecraft rendezvous}{209}{section.11.7}
 {11.8}Further reading}{213}{section.11.8}
 {paragraph}{Software tools}{213}{section*.57}
 {paragraph}{Applications}{214}{section*.58}
 {paragraph}{Falsification}{214}{section*.59}
 {subsection}{\numberline {11.8.1}Statistical model checking}{214}{subsection.11.8.1}
 {subsection}{\numberline {11.8.2}Machine learning for CPS verification}{215}{subsection.11.8.2}
 {subsection}{\numberline {11.8.3}Verification for ML}{215}{subsection.11.8.3}
 {11.9}Problems}{215}{section.11.9}
 -->
# Appendices
  * ### A Linear algebra and real analysis
  * ### B Computability and complexity
  * ### C Specification language reference